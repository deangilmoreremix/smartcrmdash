Install the package in your project through package manager.

npm install @elevenlabs/react
# or
yarn add @elevenlabs/react
# or
pnpm install @elevenlabs/react

Usage
useConversation
A React hook for managing connection and audio usage for ElevenLabs Conversational AI.

Initialize conversation
First, initialize the Conversation instance.

import { useConversation } from '@elevenlabs/react';
const conversation = useConversation();

Note that Conversational AI requires microphone access. Consider explaining and allowing access in your app’s UI before the Conversation starts.

// call after explaining to the user why the microphone access is needed
await navigator.mediaDevices.getUserMedia({ audio: true });

Options
The Conversation can be initialized with certain options

const conversation = useConversation({
  /* options object */
});

onConnect - handler called when the conversation websocket connection is established.
onDisconnect - handler called when the conversation websocket connection is ended.
onMessage - handler called when a new message is received. These can be tentative or final transcriptions of user voice, replies produced by LLM, or debug message when a debug option is enabled.
onError - handler called when a error is encountered.
Methods
startSession
The startConversation method kicks off the WebSocket or WebRTC connection and starts using the microphone to communicate with the ElevenLabs Conversational AI agent. The method accepts an options object, with the signedUrl, conversationToken or agentId option being required.

The Agent ID can be acquired through ElevenLabs UI.

We also recommended passing in your own end user IDs to map conversations to your users.

const conversation = useConversation();
// For public agents, pass in the agent ID and the connection type
const conversationId = await conversation.startSession({
  agentId: '<your-agent-id>',
  connectionType: 'webrtc', // either "webrtc" or "websocket"
  user_id: '<your-end-user-id>', // optional field
});

For public agents (i.e. agents that don’t have authentication enabled), only the agentId is required.

In case the conversation requires authorization, use the REST API to generate signed links for a WebSocket connection or a conversation token for a WebRTC connection.

startSession returns a promise resolving a conversationId. The value is a globally unique conversation ID you can use to identify separate conversations.

WebSocket connection
WebRTC connection
// Node.js server
app.get("/signed-url", yourAuthMiddleware, async (req, res) => {
  const response = await fetch(
    `https://api.elevenlabs.io/v1/convai/conversation/get-signed-url?agent_id=${process.env.AGENT_ID}`,
    {
      headers: {
        // Requesting a signed url requires your ElevenLabs API key
        // Do NOT expose your API key to the client!
        "xi-api-key": process.env.ELEVENLABS_API_KEY,
      },
    }
  );
  if (!response.ok) {
    return res.status(500).send("Failed to get signed URL");
  }
  const body = await response.json();
  res.send(body.signed_url);
});

// Client
const response = await fetch("/signed-url", yourAuthHeaders);
const signedUrl = await response.text();
const conversation = await Conversation.startSession({
  signedUrl,
  connectionType: "websocket",
});

endSession
A method to manually end the conversation. The method will disconnect and end the conversation.

await conversation.endSession();

setVolume
Sets the output volume of the conversation. Accepts an object with a volume field between 0 and 1.

await conversation.setVolume({ volume: 0.5 });

status
A React state containing the current status of the conversation.

const { status } = useConversation();
console.log(status); // "connected" or "disconnected"

isSpeaking
A React state containing information on whether the agent is currently speaking. This is useful for indicating agent status in your UI.

const { isSpeaking } = useConversation();
console.log(isSpeaking); // boolean

Was this page helpful?
Yes
No
